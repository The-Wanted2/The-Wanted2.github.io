<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jquery笔记]]></title>
    <url>%2F2019%2F08%2F31%2Fjquery%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、jquery选择器1234567891011121314$(&quot;#bookId_input&quot;) //获得id为bookId_input的元素 $(&quot;.main&quot;) //获得所有class为main的元素$(&quot;p&quot;) //获得所有p标签$(&quot;.main p&quot;) //获得所有class为main的元素的子元素p$(&quot;*&quot;) //获得所有元素$(this) //获得当前元素$(&quot;p.intro&quot;) //获得class为intro的p标签$(&quot;p:first&quot;) //第一个p标签$(&quot;ul li:first&quot;) //第一个ul的第一个子元素li$(&quot;ul li:first-child&quot;) //每一个ul的第一个子元素li$(&quot;[href]&quot;) //所有有属性href的元素$(&quot;a[target=&apos;_blank&apos;]&quot;) //所有属性target=&quot;_blank&quot;的a标签$(&quot;a[target!=&apos;_blank&apos;]&quot;)//所有属性target不等于&apos;_blank&apos;的a标签$(&quot;:button&quot;) //所有type=button的input标签和button标签 二、隐藏和显示标签1234$(&quot;p&quot;).hide() //隐藏选择器选中的标签$(&quot;p&quot;).show() //显示选择器选中的标签$(selector).hide(speed,callback) //speed是隐藏的毫秒值，callback是隐藏之后执行的方法$(&quot;p&quot;).toggle() //在隐藏和显示之间切换 $(selector).hide(speed,callback) 如果选择选中的元素有n个，则回调函数也会执行n次]]></content>
      <tags>
        <tag>前端 jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven项目管理]]></title>
    <url>%2F2019%2F08%2F03%2Fmaven%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、maven的安装与配置下载某个版本的maven并解压到某个路径下，接下来需要配置maven的环境变量： M2_HOME = [maven的解压路径]path = %M2_HOME%\bin 配置好后在cmd中输入 mvn -v 测试配置是否成功 二、maven本地仓库maven会在本地创建一个仓库，用来存放从maven中央仓库下载下来的jar包和maven插件，本地仓库的地址默认为： C:\user\~\.m2\repository。 可以修改 apache-maven-*\conf\settings.xml 中的配置来修改本地仓库的路径，配置如下： 1&lt;localRepository&gt;[本地仓库指定路径]&lt;/localRepository&gt; 三、手动创建maven工程以项目Hello为例 项目的目录结构这是maven项目固定的目录结构Hello|—src|—|—main|—|—|—java （项目主要代码）|—|—|—resources （一般存放项目的一些配置文件）|—|—test|—|—|—java （项目测试程序）|—|—|—resources （存放项目测试程序的一些配置文件）|—pom.xml （在该文件中配置项目所依赖的jar包和插件） pom.xml文件的内容在该文件中主要配置的是maven项目依赖的jar包以及插件，内容如下： 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 下面是对项目名称及版本信息的配置，根据下面的配置， 打包产生的jar包为： Hello-0.0.1-SNAPSHOT.jar --&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;Hello&lt;/name&gt; &lt;!-- 工程所以依赖的jar包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 主程序在src/main/java/com/jizuhao/maven目录下新建文件Hello.java，内容如下: 123456package com.jizuhao.maven;public class Hello &#123; public String sayHello(String name)&#123; return &quot;Hello &quot;+name+&quot;!&quot;; &#125;&#125; 测试程序在/src/test/java/com/jizuhao/maven目录下新建测试文件HelloTest.java: 1234567891011package com.jizuhao.maven; import org.junit.Test;import static junit.framework.Assert.*;public class HelloTest &#123; @Test public void testHello()&#123; Hello hello = new Hello(); String results = hello.sayHello(&quot;litingwei&quot;); assertEquals(&quot;Hello litingwei!&quot;,results); &#125;&#125; 四、maven常用的命令123456mvn compile 编译主程序mvn clean 清理编译和打包产生的target文件夹mvn test-complie 编译测试程序mvn test 运行测试程序mvn package 将项目打成jar包，mvn install 将工程放入本地仓库中，这样就能向引用其他jar包一样，引用该工程中的jar包。 注意：在cmd中运行Maven命令时一定要进入pom.xml文件所在的目录！ 五、jar包的生命周期在引入jar包时，需要指定一个属性scope，这个属性指定jar包的作用范围，总共有如下5种取值： compile：scope的默认值，表示jar包可以在整个生命周期中使用。项目发布之后jar包也跟随发布 provided：跟compile相似，但是表明了jar包由JDK或者容器提供，例如：Servlet API和一些JavaEE API。这个scope 只能作用在编译和测试时，同时不具有传递性，jar包不会跟随项目一起发布。 runtime:表示jar不作用在编译时，但会作用在运行和测试时，例如：JDBC驱动，适用运行和测试阶段。 test:表示jar包作用在测试时，不作用在运行时。 只在测试时使用，用于编译和运行测试代码，不会随项目发布。 system:跟provided相似，但是在系统中要以外部JAR包的形式提供，maven不会在仓库中查找它。 六、maven的基本配置 设置maven依赖的jdk版本打开settings.xml文件，找到profiles标签，加入如下配置： 123456789101112&lt;profile&gt;&lt;id&gt;jdk-1.7&lt;/id&gt;&lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt;&lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 更换maven的中央仓库镜像打开settings.xml文件，找到mirrors标签，加入如下配置： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; 七、依赖关系的传递假设存在项目MakeFriend、HelloFriend、Hello三个项目,其中MakeFriend依赖项目HelloFriend,HelloFriend依赖项目Hello。那么在项目HelloFriend种只需要导入HelloFriend,就会自动将Hello也加入到MakeFriend的依赖中。 注意:这种依赖的传递只存在于scope为complie类型的依赖。 八、依赖的排除情景：项目B依赖项目A，项目C依赖项目B，由于依赖的传递性，C在引入依赖B的同时会引入A，但是C不想引入B依赖的A，这时候就需要使用依赖的排除使得C不引入依赖A。在项目C的pom.xml文件中，引入项目B的时候添加如下内容，就能排除对A的依赖。 123456&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;A的groupId&lt;/groupId&gt; &lt;artifactId&gt;A的artifactId&lt;/artifactId&gt; &lt;/exclusion&gt;&lt;/exclusions&gt; 九、maven依赖传递的原则 情景1：项目B依赖低版本的项目A，项目C依赖高版本的A和B，如果在C中引入B和高版本的A，则低版本的A不会被自动引入到C中。 情景2：项目B依赖低版本的项目A，项目C依赖B和高版本的A，项目D依赖C，如果在D中只明确引入C，这时候传递给D的是高版本的A。因为maven依赖的传递按照的是就近原则。 情景3：项目B依赖低版本的项目A，项目C依赖高版本的A，项目D依赖B和C，这时候maven按照先引入优先的原则，来自动引入A。如果D先引入B，则自动引入低版本的A，如果D先引入C则自动引入高版本的A。 十、pom.xml中的properties标签在properties中可以自定义标签，然后在pom.xml的其他位置可以使用“${自定义标签名}”来引用自定义标签的值。例如:通过在properties中自定义标签来统一管理spring各jar包的版本号 1234567891011121314151617181920212223&lt;properties&gt; &lt;spring-version&gt;4.3.7.RELEASE&lt;/spring-version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--引入spring、springmvc需要的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--事务控制需要的jar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--面向切面编程的jar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 十一、聚合与继承1. 继承 情景：Hello依赖的junit为4.0版本，HelloFriend依赖的junit为4.0版本，MakeFriends依赖的junit为4.9版本。由于test类型的依赖不能传递，所以必然会分散在各个模块中，很容易造成版本不一致。 需求：统一管理各模块中junit依赖的版本。 解决思路：将junit依赖统一提取到一个父工程中，然后将父工程引入子工程中，另外在子工程中声明junit依赖时，不指定版本号，以父工程中的依赖为准，便于统一管理依赖。 步骤： 创建一个maven工程作为父工程，注意：打包的方式为pom； 在子工程中声明对父工程的引用； 将子工程的坐标中与父工程中坐标重复的内容删除; 在父工程中统一junit依赖; 在子工程中引入junit依赖时不声明版本号 完整的配置: 父工程的pom.xml 12345678910111213141516171819202122&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Maven_parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; Hello/pom.xml 1234567891011121314151617181920212223242526&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--如果子工程的groupId、version和父工程的一样，这里就不用声明--&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;!-- 在子工程供声明父工程 --&gt; &lt;parent&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Maven_parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 父工程中pom文件的位置 --&gt; &lt;relativePath&gt;../Maven_parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--这里不用声明junit的版本信息--&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; HelloFriend/pom.xml 123456789101112131415161718192021222324252627282930&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt; &lt;parent&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Maven_parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 父工程中pom文件的位置 --&gt; &lt;relativePath&gt;../Maven_parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; MakeFriend/pom.xml 123456789101112131415161718192021222324252627282930&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;makeFriend&lt;/artifactId&gt; &lt;parent&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Maven_parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../Maven_parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 特别注意：使用了继承之后install的时候必须要先install父工程 2. 聚合 作用：在父工程中声明聚合之后，就只需要install父工程就能自动完成对子工程的install 操作：在上述父工程的pom.xml中加入如下内容，完成项目的聚合 1234567 &lt;!--创建聚合--&gt; &lt;modules&gt;&lt;!-- 各个子工程的相对路径 --&gt;&lt;module&gt;../Hello&lt;/module&gt;&lt;module&gt;../HelloFriend&lt;/module&gt;&lt;module&gt;../makeFriend&lt;/module&gt; &lt;/modules&gt; 十二、在idea上使用maven开发web项目 创建项目选择maven-&gt;选择骨架为webApps-&gt;在src/main下面创建java文件夹，然后make dir as resources root-&gt;再src下创建test文件夹，然后make dir as test resources root 加入插件方便调试在项目中加入这个插件之后，只需要点击maven-&gt;plugins-&gt;tomcat7-&gt;run就能启动项目，方便对项目进行调试 1234567891011121314&lt;build&gt; &lt;finalName&gt;ssm&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习路线]]></title>
    <url>%2F2019%2F08%2F02%2Fjava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[一、基础知识 编程语言: Java python c 基本语法 基本网络知识: tcp/ip http/https 基本的设计模式 二、工具方面 操作系统：Linux （centos/Ubuntu） 代码管理：svn/git 持续集成：CI/CD Jenkins Java项目管理工具：maven/gradle 三、框架方面应用框架 ssh（spring+structs+hibernate）已过时 ssm spring boot 中间件 MQ消息对列 RPC通讯框架 gRPC thrift dubbo springcloud elasticsearch 搜索引擎 数据库 SQL：MySQL/postgre sql Nosql：redis memcached mongodb elasticsearch 四、架构方面分布式/微服务架构 spring cloud dubbo rpc通信 虚拟化/容器化 Docker 容器化 k8s kubernetes 五、关注源码/性能 JDK 源码以及部分设计思想 Spring源码 JVM细节与排错 高并发/高可用 六、推荐的图书 java编程思想 java并发编程实战 深入理解java虚拟机 head First 设计模式 函数式编程思维 Tcp/Ip详解 卷1/卷2 鸟哥的linux私房菜 spring技术内幕]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的基本语法]]></title>
    <url>%2F2019%2F08%2F01%2Fmarkdowm%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 注意：标题内容和最后一个#号之间有1个空格。 效果： 二、字体1234*这是斜体***这是粗体*****斜体加粗***~删除线~ 效果：这是斜体这是粗体斜体加粗删除线 三、引用123&gt;引用&gt;&gt;引用&gt;&gt;&gt;引用 提示：通过上面的例子可以发现，&#39;&gt;&#39;可以嵌套使用。 效果： 引用 引用 引用 四、分割线1234---***---**** 提示：三个及以上个数的&#39;*&#39;或者&#39;-&#39;都能产生一条横线， 五、引入图片1![图片不见了](/images/logo.jpg &quot;标题&quot;) 提示：[]包裹的图片链接失效时的提示信息，()内前半部分是图片的地址,这里使用的是绝对路径，也可以使用url来引用网络上的图片,鼠标悬浮在图片上时显示的内容，有些浏览器不支持,该内容是可选的。 效果： 六、超链接1[baidu](http://baidu.com) 效果：baidu 七、换行 说明：如果我们想把一行文本进行换行，我们可以在需要换行的地方输入至少两个空格，然后回车即可。 例如： 12markdown 另起一行 效果：markdown另起一行 八、代码块 说明：单行代码使用``这个符号括起来，就能显示成一个代码块。多行代码使用至少4个空格缩进或者一个tab键或者使用``` ```将代码块包起来，都能以代码块的形式显示多行代码。 例如： 12345`&lt;html&gt;&lt;/html&gt;`**** public static void main(String[] args)&#123; System.out.println(&quot;hello world!&quot;); &#125; 效果：&lt;html&gt;&lt;/html&gt; public static void main(String[] args){ System.out.println(&quot;hello world!&quot;); }九、列表 说明：*和+和-后面跟一个空格产生一个无序列表数字或字母后面跟一个.然后再跟一个空格就会产生有序列表 例如： * 列表1 * 子列表1 * 子列表2 - 列表2 - 子列表1 - 子列表2 + 列表3 + 子列表1 + 子列表2 **** 1. 列表1 a. 子列表1 b. 子列表2 2. 列表2 a. 子列表1 b. 子列表2 3. 列表3 a. 子列表1 b. 子列表2效果： 列表1 子列表1 子列表2 列表2 子列表1 子列表2 列表3 子列表1 子列表2 列表1a. 子列表1b. 子列表2 列表2a. 子列表1b. 子列表2 列表3a. 子列表1b. 子列表2]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>标记语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、搭建个人博客的详细过程1.下载安装Node.js Node.js带有一个包管理器npm。安装好Node.js之后，npm会自动配置到环境变量中 2.更换npm的源 首先进入cmd，输入如下命令：npm install -g cnpm –registry=https://registry.npm.taobao.org通过这个命令，安装了cnpm,并将其源设置为了淘宝的源。接下来将使用cnpm来代替npm。 3.安装Hexo 输入如下指令：cnpm install -g hexo-cli 4.创建博客站点的文件夹 任意再一个路径下创建一个文件夹，之后将再这个文件夹中创建博客站点 5.初始化博客站点 在cmd中进入刚才创建的文件夹中，然后输入如下指令：hexo init提示：如果显示找不到指令hexo，就输入：cnpm install 6.启动本地服务进行测试 初始化博客站点完成之后，输入如下指令开启本地服务：hexo server然后进入浏览器访问localhost:4000，如果成功了会显示一个默认的博客，此时已经完成了个人博客的搭建。 二、编写博客的步骤1.编辑博文 在cmd中进入博客站点根目录，然后输入如下指令：hexo new [博文的名字]该指令会在站点目录下的source/_post下生成一个对应的md文件。使用markdown的语法，在这个文件中编写自己的博文内容。 2.生成博客 编辑保存好博文之后，在cmd中进入站点根目录，然后输入如下指令：hexo generate该指令会将站点下的所有博文统一生成一个待发布的静态网站，也就是我们的博客。该网站对应的资源文件在站点根目录下的.deploy_git下。提示：在每次生成博客之前，最好使用clean指令清理之前网站文件夹。 三、将个人博客托管到github1.创建托干博客的仓库 创建一个github仓库，仓库名必须是 username.github.io 例如我的用户名为The-Wanted2,所以我托管博客的仓库名为 The-Wanted2.github.io 2.安装发布博客所需的工具 输入: cnpm install –save hexo-deployer-git，安装发布到github所需的工具， 3.设置仓库的地址 打开站点根目录下的_config.yml文件，修改文件的最后几行，设置github仓库的地址内容如下： 4.发布博文 在cmd中进入站点根目录，输入如下指令：hexo deploy该指令会将站点根目录下的.deploy_git发布到上面指定的仓库中之后就能通过访问：The-Wanted2.github.io 来访问博客]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
