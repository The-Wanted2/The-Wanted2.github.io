<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux基本命令]]></title>
    <url>%2F2019%2F10%2F18%2Flinux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、用户管理命令1.修改用户密码命令格式：passwd [用户名]注意：普通用户只能修改自己的密码，root用户可以指定所有用户进行密码修改。 2.添加用户命令格式：useradd –d /usr/jzh -m jzh说明：-d 参数表示在/usr目录下创建用户的主目录jzh。注意：只有root用户才能创建用户，并且只有设置密码之后用户才能登录 3.删除用户命令格式：userdel -r [用户名]说明：-r参数表示在删除用户的同时删除用户的主目录注意：只有root用户才能删除用户，且在用户登录的状态下不能删除用户。 4.切换登录用户命令格式：su [用户名]说明：用户名默认为root 5.查看登录信息whoami–当前登录用户的用户名who–查看当前所有登录系统的用户信息last–查看最近登录的用户信息 6.修改用户信息命令格式：usermod -s /bin/ksh -d /home/jzh2 –g developer jzh参数说明：-s设置用户的登录shell为ksh；-d设置用户主目录；-g设置用户的主组；-l修改用户登录名；-G添加用户所属的组 7.创建用户组命令：groupadd -g 101 developer参数说明：-g用于设置新用户组的组标识号 8.删除用户组命令：groupdel developer注意：删除用户组的前提是没有用以该组为主组 9.修改用户组的属性命令:groupmod –g 10000 -n developer group参数说明：-g修改用户组的组标识号-n修改用户组的名称 10.切换用户组命令：newgrp root说明：如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。 11.查看当前用户所属的组命令：groups [用户名]说明：用户名默认为当前用户 二、常用命令1.关机、重启和注销1234567shutdown -h now //关机 shutdown -h hours:minutes //定时关机 poweroff //关机 shutdown -h 10 //10分钟后关机 shutdown -r now //立即重启 reboot //立即重启shotdown -c //取消定时关机 2.文件和目录123456789101112131415161718192021222324252627282930313233cd /home //进入“/home“目录 cd .. //返回上级目录 cd ../.. //返回上两级目录 cd //进入用户主目录 cd - //返回上一次所在的目录 pwd //显示工作路径 ls [路径] //显示指定路径下的文件和目录，默认为当前路径 ls -a //显示路径下的所有文件和目录，包括隐藏文件 ls -l //显示文件和路径的详细信息 tree [路径] //树形显示文件夹下的情况 mkdir [路径名] //创建文件夹 mkdir -p dir1/dir2 //创建多级目录 rm -f test.txt //删除文件 rm -d dir1 //删除一个空文件夹 rm -rf dir1 //删除一个文件夹及其路径下的子目录和文件 rmdir dir1 //删除一个空文件夹 mv 1.txt 2.txt //修改文件或文件夹名 mv 1.txt dir1/1.txt //移动文件或文件夹到dir1下 cp 1.txt dir1 //复制文件到路径dir1下 cp -r dir1 dir2 //递归复制dir1及dir1下的文件和文件夹到dir2下 cp dir1/* dir2 //复制路径dir1下的所有文件到dir2下 cp -a dir1/dir2 dir3 //复制dir1下的dir2（包括dir2下的所有文件和文件夹）到dir3 ln -s 1.txt link1 //给文件或文件夹创建一个软链接（类似于windows的快捷键，对链接文件和链接文件所指向的文件进行操作是等效的，对其中一个文件进行操作，两处都会生效）ln 1.txt link2 //给文件创建一个硬链接。文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。touch 1.txt //创建文件，可以同时创建多个文件touch -c 1.txt //如果文件1.txt存在，则更新文件修改时间，如果文件不存在则什么也不干touch -r 1.txt 2.txt //修改文件1.txt的时间戳和2.txt的时间戳相同find dir1 -name 1.txt //在路径dir1下按照文件名查找1.txt（-name表示按文件名查找，-user表示按照所有者查找，-group表示按照所属组查找）wc file //统计文件内容的行数、单词数、字节数。单词数是以空白字符来界定的echo $JAVA_HOME //输出环境变量JAVA_HOME的值echo content &gt; file //向文件中写如内容，之前的内容会被清空echo content &gt;&gt; file //向文件中追加内容。 env //显示所有环境变量 3.查看文件内容12345678cat 1.txt -n //显示文件的内容，-n表示显示行号cat -&gt; 1.txt //-表示从标准输入读取，&gt;表示读取到的内容重定向到1.txt中more -10 1.txt //从1.txt中读取1屏的内容显示出来，-10表示每屏的行数，输入空格向下翻页，输入回车读取一行more +10 1.txt //从第10行开始显示文件内容less 1.txt //查看1.txt的内容，输入空格向下翻页，输入回车读取一行，输入b向上翻页tail -10 1.txt //查看文件尾部10行的内容head -10 1.txt //查看文件首部10行的内容grep -n key 1.txt //在文件1.txt中查找关键字key所在的行并显示出来，-n表示显示的时候标出行号 4.文件属性Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：第一个字段中的第一个字符代表这个文件是目录、文件或链接文件等等。 d 目录 - 普通文件 l 链接文件 b 块设备文件 c 字符设备文件 p 命名管道文件 s socket文件 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。第1-3位确定文件所有者拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。对于 root 用户来说，一般情况下，文件的权限对其不起作用。第二个字段表示文件的链接数。第三个字段表示文件的所有者。第四个字段表示文件的所属组。第五个字段表示文件的大小，以字节为单位。第六、七、八个字段表示文件最近一次修改的时间。第九个字段表示文件的名称。 修改文件属性：文件的所有者和root可以修改文件的权限，root可以修改文件的所有者。 12345678910chown [-R] 属主名 文件名 //修改文件的所有者，-R表示如果是文件夹，则递归修文件夹下的所有文件的所有者chown [-R] 属主名：属组名 文件名 //修改文件的所有者和所属组chgrp [-R] 属组名 文件名 //修改文件的所属组，-R表示如果是文件夹，则递归修文件夹下的所有文件的所有者chmod u+rwx 文件名 //为该文件添加所属用户的权限chmod a-rwx 文件名 //取消所有人对该文件的读、写、执行权限chmod g=rwx 文件名 //设置该文件所属组的权限(u代表所属用户 o代表其他用户 g代表所属组的成员用户 a代表所有人)(+代表添加权限、-代表取消权限，=表示设置权限)chmod 765 文件名 //同时设置文件所有者、所属组、其他人的权限(7--&gt;111--&gt;rwx,6--&gt;110--&gt;rw-,5--&gt;101--&gt;r-x) 5.系统管理12345678free //查看系统内存的使用情况top //查看实时刷新的系统进程信息ps -ef //查看系统瞬间的进程信息快照ps -ef | grep myshell.sh //搜索myshell进程的信息，这里使用管道将ps -ef获得的结果通过管道传递给grep作为参数netstat -tunlp //查看tcp、udp占用的端口和进程PIDnetstat -tunlp | grep 3306 //查看端口3306的占用情况kill -9 PID //强制杀死进程号为PID的进程ifconfig //查看本机ip等信息 6.打包与归档1234567891011121314gzip file //压缩文件，压缩之后原文件被删除，产生file.gzgzip -r dir1 //递归将文件夹下的所有文件进行压缩（如果dir1下存在dir2，也会将dir2下的文件进行压缩），每个文件对应一个压缩包。gzip -d file.gz //将文件file.gz进行解压，解压之后file.gz被删除，产生file文件gzip -c file &gt; file.gz //压缩文件file，并保留原来的文件。 -c参数表示把压缩后的文件输出到标准输出设备，不去更动原始文件。gzip -cd file.gz &gt; file //解压文件file.gz，并保留压缩文件bzip2 file //压缩文件，压缩之后原文件被删除，产生file.bz2bzip2 -d file.bz2 //解压文件，解压之后将不保留压缩文件，产生filebzip2 -k file //压缩文件，-k表示保留原文件 bzip2 -c file //将压缩后的文件写入标注输出设备tar -cvf dir1.tar ./dir1 //打包文件或文件夹，生成dir1.tar，打包之后并不删除原来的文件或文件夹。 -c表示压缩 -v表示压缩过程中详细报告tar处理的文件信息 tar -xvf dir1.tar //将tar文件解压到当前文件夹tar -zcvf dir1.tar.gz dir1 //将文件夹dir1先打包在进行压缩，-z表示压缩的时候使用gzip方式]]></content>
      <categories>
        <category>学习小结&amp;笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--GoF]]></title>
    <url>%2F2019%2F09%2F18%2FGoF--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、设计模式概述1.面向对象设计原则一个可维护性较低的软件设计通常由如下四个原因造成： 过于僵硬：很难在一个软件系统中添加新的功能，增加一个新的功能将涉及多个模块，造成系统改动较大。例如在源代码中存在大量的硬编码，几乎所有的修改都要面向程序源代码进行。 过于脆弱：与“过于僵硬”同时存在，修改已有系统时代码过于脆弱，对一个地方的修改会导致看上去没有关系的另一个地方发生故障。 复用率低：复用是指一个软件的组成部分可以在同一个项目的不同地方甚至在不同的项目中重用。复用率低则相反。 黏度过高：对系统进行改动时，有时候可以保存系统的原始设计意图和原始设计框架，有时候可以破坏原始意图和框架。前者对系统的扩展性更有利，应该尽量按照前者进行改动。如果采用后者比前者更容易，则称系统的黏度过高，黏度过高将导致程序员采用错误的代码维护方案。 一个好的系统设计应该具备下面的三个特性： 可扩展性：容易将新的功能添加到现有的系统中，与“过于僵硬”相对应。 灵活性：代码修改时不会涉及很多其他的模块，与“过于脆弱”相对应。 可插入性：可以很方便的将一个类抽取出来，同时将另一个有相同接口的类添加进来，与“黏度过高”相对应。 如何使系统满足上面三个性质，其关键在于恰当的提高系统的可维护性和可复用性。传统的代码复用技术，有时候会导致系统的可维护性降低。例如：A和B都需要使用同一个模块C，如果A需要C添加一个新的行为，但B不需要甚至不允许C增加该行为。如果坚持复用C，就不得不以系统的可维护性为代价，如修改B的代码。如果从保持系统可维护性的角度出发，就只好放弃复用。面向对象设计复用在一定程度上可以解决两者的矛盾。 面向对象设计复用的目标在于实现支持可维护性的复用。通过抽象和继承使得类的定义可以复用，通过多态使得类的实现可以复用，通过抽象和封装可以保持和促进系统的可维护性。 每一种设计模式都蕴含着至少一种面向对象设计原则，面向对象设计原则包含如下7个： 原则名称 原则解释 单一职责原则 类的职责要单一，不能将太多的职责放在一个类中。 开闭原则 软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能 里氏代换原则 在软件系统中，一个可以接受基类对象的地方一定可以接受一个子类的对象 依赖倒转原则 要针对抽象层编程，不要针对具体类编程 接口隔离原则 使用多个专门的接口来取代一个统一的接口 合成复用原则 在复用功能时，尽量多使用组合和聚合关系，少使用甚至不适用继承关系 迪米特法则 一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此直接通信，那么两个类就不应该发生直接的相互作用，而是通过引入一个第三者完成间接交互 2.设计模式的分类根据目的、用途的不同将设计模式分为：创建性模式、结构性模式和行为性模式。创建型模式主要用于创建对象，结构型模式主要用于处理类和对象的组合，行为性模式主要用于描述类或对象的交互以及职责分配。 根据处理范围的不同设计模式又可分为：类模式和对象模式。类模式处理类与子类的关系，这种关系通过继承来建立，属于静态关系，在编译时候确定下来；对象模式处理对象之间的关系，关系在运行时发生变化，属于动态关系。 GoF 23种设计模式： 创建型模式 结构型模式 行为型模式 类模式 工厂方法模式 （类）适配器模式 解释器模式、模板方法模式 对象模式 抽象工厂模式、建造者模式、原型模式、单例模式 （对象）适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式 职责链模式、命令模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、访问者模式 二、创建型模式创建型模式关注对象的创建过程，它将对象的创建和使用分离，在使用对象时无需知道对象的创建细节，外界对于这些对象只需要知道他们的公共接口，这使得整个系统的设计更加符合单一职责原则。创建型模式主要包括6种： 简单工厂模式（非GoF 23中的成员） 工厂方法模式 抽象工厂模式 建造者模式 原型模式 单例模式 1.简单工厂模式简单工厂模式又称为静态工厂方法模式，其并不是GoF23种设计模式中的一员，但是用得也比较多。简单工厂模式专门定义一个类来负责创建其他类的实例，该类拥有一个静态方法，通过传递不同的参数给该静态方法，可以获得不同类的实例对象。被创建的实例通常都具有相同的父类或实现同一个接口。 案例： 抽象基类： 123public abstract class AbstractPay &#123; public abstract void pay();&#125; 现金支付类： 123456public class CashPay extends AbstractPay &#123; @Override public void pay() &#123; System.out.println("现金支付！"); &#125;&#125; 信用卡支付类： 123456public class CreditcardPay extends AbstractPay &#123; @Override public void pay() &#123; System.out.println("信用卡支付！"); &#125;&#125; 工厂类： 1234567891011public class PayMethodFactory &#123; public static AbstractPay getPayMethod(String type)throws Exception&#123; if("cash".equals(type))&#123; return new CashPay(); &#125;else if("creditcard".equals(type))&#123; return new CreditcardPay(); &#125;else&#123; throw new Exception("不支持"+type+"类型的支付方式！"); &#125; &#125;&#125; 测试： 12345678910public class Client &#123; public static void main(String[] args)throws Exception&#123; System.out.println("--------------现金支付--------------"); AbstractPay cashPay = PayMethodFactory.getPayMethod("cash"); cashPay.pay(); System.out.println("---------------信用卡支付-------------"); AbstractPay creditcardPay = PayMethodFactory.getPayMethod("creditcard"); creditcardPay.pay(); &#125;&#125; 运行结果： 总结： 简单工厂模式存在的最大的问题在于工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断逻辑，这一点与开闭原则相违背。 另外，静态工厂中的方法是静态的，静态方法存在一个问题：java中子类不能通过重写父类的静态方法来实现对父类静态方法的扩展。对于静态方法的调用是根据引用类型来判断的，而不是根据引用所指向的实例的类型来判断的。换句话说，父类类型的引用即使指向的是子类的实例，且子类重新定义了父类的静态方法，父类引用在调用该静态方法时，也只会调用该静态方法在父类中的定义。 1234567891011121314151617181920public class SuperClass &#123; public static void fun()&#123; System.out.println("father"); &#125; public static void main(String[] args) &#123; SuperClass c = new SubClass(); c.fun();//调用的是父类的fun方法 &#125;&#125;class SubClass extends SuperClass&#123; //加上这个注解会报错，因为子类不能重写父类的静态方法 //@Override public static void fun()&#123; System.out.println("son"); &#125;&#125; 2.工厂方法模式工厂方法模式是GoF23种设计模式中的一员，这种模式与简单工厂模式很大的不同在于该模式将工厂类的职责进行了细分，其中定义了一个父类工厂用于定义创建产品对象的公共接口，对于每一类产品，都需要有一个对应的工厂类，该工厂类实现父类工厂接口，通过每种产品的工厂来分别获得每种产品的实例对象，而不是通过一个工厂类来获得所有产品的实例对象。 案例： 抽象工厂： 123public abstract class PayMethodFactory &#123; public abstract AbstractPay getPayMethod();&#125; 现金支付工厂： 123456public class CashPayFactory extends PayMethodFactory&#123; @Override public AbstractPay getPayMethod() &#123; return new CashPay(); &#125;&#125; 信用卡支付工厂类： 123456public class CreditCardPayFactory extends PayMethodFactory &#123; @Override public AbstractPay getPayMethod() &#123; return new CreditcardPay(); &#125;&#125; 支付方式的抽象基类： 123public abstract class AbstractPay &#123; public abstract void pay();&#125; 现金支付类： 123456public class CashPay extends AbstractPay &#123; @Override public void pay() &#123; System.out.println("现金支付！"); &#125;&#125; 信用卡支付类： 123456public class CreditcardPay extends AbstractPay&#123; @Override public void pay() &#123; System.out.println("信用卡支付！"); &#125;&#125; 测试： 12345678public static void main(String[] args) &#123; PayMethodFactory factory1 = new CashPayFactory(); AbstractPay cashPay = factory1.getPayMethod(); cashPay.pay(); PayMethodFactory factory2= new CreditCardPayFactory(); AbstractPay creditCardPay = factory2.getPayMethod(); creditCardPay.pay();&#125; 总结： 优点： 具有很好的可扩展性。当要添加新的产品时，只需要添加产品类和对应产品的工厂类，不需要修改已有代码，完全符合“开闭原则”。 缺点： 针对每一个产品都需要有一个工厂类，增加了系统的复杂度。 3.抽象工厂模式抽象工厂模式是工厂方法模式的泛化版，工厂方法模式是一种特殊的抽象工厂方法模式。在工厂方法模式中，每一个具体的工厂只能生产一种具体的产品。而在抽象工厂模式中，每一个的具体的工厂可以产生多个具体的产品，一个工厂生产的所有产品构成一个产品族。 抽象工厂模式中的角色： AbstractFactory（抽象工厂） 用于声明生成抽象产品的方法，在一个抽象工厂中可以定义一组方法，每一个方法对应一个产品等级结构。 ConcreteFactory（具体工厂） 具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体的产品。这些产品构成一个产品族，每一个产品都位于某个产品等级结构中。 AbstractProduct（抽象产品） 抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法。 ConcreteProduct（具体产品） 具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。 案例： 电视接口： 123public interface TV &#123; public void play();&#125; 空调接口： 123public interface AirConditioner &#123; public void changeTemperature();&#125; Haier电视类： 12345public class HaierTV implements TV &#123; public void play()&#123; System.out.println("海尔电视机播放。。。。。。"); &#125;&#125; Haier空调类： 12345public class HaierAirConditioner implements AirConditioner &#123; public void changeTemperature()&#123; System.out.println("海尔空调改变温度....."); &#125;&#125; TCL电视类： 12345public class TCLTV implements TV &#123; public void play()&#123; System.out.println("TCL 电视机播放....."); &#125;&#125; TCL空调类： 12345public class TCLAirConditioner implements AirConditioner &#123; public void changeTemperature()&#123; System.out.println("TCL空调改变温度......."); &#125;&#125; 工厂类接口： 1234public interface EFactory &#123; public TV productTV(); public AirConditioner productAirConditioner();&#125; Haier工厂类： 12345678910public class HaierFactory implements EFactory &#123; @Override public TV productTV() &#123; return new HaierTV(); &#125; @Override public AirConditioner productAirConditioner() &#123; return new HaierAirConditioner(); &#125;&#125; TCL工厂类： 12345678910public class TCLFactory implements EFactory &#123; @Override public TV productTV() &#123; return new TCLTV(); &#125; @Override public AirConditioner productAirConditioner() &#123; return new TCLAirConditioner(); &#125;&#125; 测试： 1234567public static void main(String[] args) &#123; EFactory factory = new HaierFactory(); TV tv = factory.productTV(); tv.play(); AirConditioner airConditioner = factory.productAirConditioner(); airConditioner.changeTemperature();&#125; 总结： 抽象工厂模式的优点： 抽象工厂可以实现高内聚低耦合的设计目的。 增加新的具体工厂和产品族很方便，无需修改已有的系统，符合“开闭原则”。 抽象工厂模式的缺点： 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对接口进行扩展，而这涉及对抽象工厂角色及其子类的修改。 4.建造者模式]]></content>
      <categories>
        <category>学习小结&amp;笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery笔记]]></title>
    <url>%2F2019%2F08%2F31%2Fjquery%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、jquery选择器1234567891011121314$(&quot;#bookId_input&quot;); //获得id为bookId_input的元素 $(&quot;.main&quot;); //获得所有class为main的元素$(&quot;p&quot;); //获得所有p标签$(&quot;.main p&quot;); //获得所有class为main的元素的子元素p$(&quot;*&quot;); //获得所有元素$(this); //获得当前元素$(&quot;p.intro&quot;); //获得class为intro的p标签$(&quot;p:first&quot;); //第一个p标签$(&quot;ul li:first&quot;); //第一个ul的第一个子元素li$(&quot;ul li:first-child&quot;); //每一个ul的第一个子元素li$(&quot;[href]&quot;); //所有具有href属性的元素$(&quot;a[target=&apos;_blank&apos;]&quot;); //所有属性target=&quot;_blank&quot;的a标签$(&quot;a[target!=&apos;_blank&apos;]&quot;); //所有属性target不等于&apos;_blank&apos;的a标签$(&quot;:button&quot;); //所有type=button的input标签和button标签 二、隐藏和显示标签1234$(&quot;p&quot;).hide(); //隐藏选择器选中的标签$(&quot;p&quot;).show(); //显示选择器选中的标签$(selector).hide(speed,callback);//speed是隐藏的延迟事件（单位为毫秒），callback是隐藏之后执行的方法$(&quot;p&quot;).toggle(); //在隐藏和显示之间切换 提示：$(selector).hide(speed,callback) 如果选择选中的元素有n个，则回调函数也会执行n次。 三、标签属性设置标签属性： 12$(selector).attr(&quot;属性名&quot;,value); $(selector).prop(&quot;属性名&quot;,value); 获得标签属性： 12var attr = $(selector).attr(&quot;属性名&quot;); var prop = $(selector).prop(&quot;属性名&quot;); 两者的区别：attr()一般用于设置自定义属性的值prop()一般用于设置html标签自带的属性的值,例如checkbox的checked的属性 四、事件绑定有些标签在页面加载时并不存在，而是通过后期事件动态添加的，如果在页面加载的时候给标签绑定事件是无效的，对于后期加载出来的标签，应该使用下面的方式来绑定事件： $(document).on(“事件名”,”选择器”,事件方法);例如： 123$(document).on(&quot;cilck&quot;,&quot;#next_page&quot;,function()&#123; alert(&quot;下一页&quot;);&#125;) 五、标签样式12$(selector).addClass(&quot;class1 class2&quot;); //给标签添加一个或多个样式$(selector).removeClass(&quot;class1 class2&quot;); //移除标签的一个或的多个样式 六、标签的添加和删除123$(selector_father).append($(&quot;&lt;p&gt;&lt;/p&gt;&quot;)); //向父元素中添加子元素p$(selector_father).remove(&quot;#image&quot;); //从父元素中删除id=image的子元素$(select).empty(); //移除选择器选中的元素 提示：使用 append() 添加子标签时，返回的是父标签，所以可以连续使用.append()来添加子标签]]></content>
      <categories>
        <category>学习小结&amp;笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven项目管理]]></title>
    <url>%2F2019%2F08%2F03%2Fmaven%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、maven的安装与配置下载某个版本的maven并解压到某个路径下，接下来需要配置maven的环境变量： M2_HOME = [maven的解压路径]path = %M2_HOME%\bin 配置好后在cmd中输入 mvn -v 测试配置是否成功 二、maven本地仓库maven会在本地创建一个仓库，用来存放从maven中央仓库下载下来的jar包和maven插件，本地仓库的地址默认为： C:\user\~\.m2\repository。 可以修改 apache-maven-*\conf\settings.xml 中的配置来修改本地仓库的路径，配置如下： 1&lt;localRepository&gt;[本地仓库指定路径]&lt;/localRepository&gt; 三、手动创建maven工程以项目Hello为例 1.项目的目录结构 这是maven项目固定的目录结构 Hello |—src |—|—main |—|—|—java （项目主要代码） |—|—|—resources （一般存放项目的一些配置文件） |—|—test |—|—|—java （项目测试程序） |—|—|—resources （存放项目测试程序的一些配置文件） |—pom.xml （在该文件中配置项目所依赖的jar包和插件）2.pom.xml文件的内容 在该文件中主要配置的是maven项目依赖的jar包以及插件，内容如下： 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 下面是对项目名称及版本信息的配置，根据下面的配置， 打包产生的jar包为： Hello-0.0.1-SNAPSHOT.jar --&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;Hello&lt;/name&gt; &lt;!-- 工程所以依赖的jar包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.主程序 在src/main/java/com/jizuhao/maven目录下新建文件Hello.java，内容如下: 123456package com.jizuhao.maven;public class Hello &#123; public String sayHello(String name)&#123; return &quot;Hello &quot;+name+&quot;!&quot;; &#125;&#125; 测试程序在/src/test/java/com/jizuhao/maven目录下新建测试文件HelloTest.java: 1234567891011package com.jizuhao.maven; import org.junit.Test;import static junit.framework.Assert.*;public class HelloTest &#123; @Test public void testHello()&#123; Hello hello = new Hello(); String results = hello.sayHello(&quot;litingwei&quot;); assertEquals(&quot;Hello litingwei!&quot;,results); &#125;&#125; 四、maven常用的命令123456mvn compile 编译主程序mvn clean 清理编译和打包产生的target文件夹mvn test-complie 编译测试程序mvn test 运行测试程序mvn package 将项目打成jar包，mvn install 将工程放入本地仓库中，这样就能向引用其他jar包一样，引用该工程中的jar包。 注意：在cmd中运行Maven命令时一定要进入pom.xml文件所在的目录！ 五、jar包的生命周期在引入jar包时，需要指定一个属性scope，这个属性指定jar包的作用范围，总共有如下5种取值： compile：scope的默认值，表示jar包可以在整个生命周期中使用。项目发布之后jar包也跟随发布 provided：跟compile相似，但是表明了jar包由JDK或者容器提供，例如：Servlet API和一些JavaEE API。这个scope 只能作用在编译和测试时，同时不具有传递性，jar包不会跟随项目一起发布。 runtime:表示jar不作用在编译时，但会作用在运行和测试时，例如：JDBC驱动，适用运行和测试阶段。 test:表示jar包作用在测试时，不作用在运行时。 只在测试时使用，用于编译和运行测试代码，不会随项目发布。 system:跟provided相似，但是在系统中要以外部JAR包的形式提供，maven不会在仓库中查找它。 六、maven的基本配置 设置maven依赖的jdk版本打开settings.xml文件，找到profiles标签，加入如下配置： 123456789101112&lt;profile&gt;&lt;id&gt;jdk-1.7&lt;/id&gt;&lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt;&lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 更换maven的中央仓库镜像打开settings.xml文件，找到mirrors标签，加入如下配置： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; 七、依赖关系的传递假设存在项目MakeFriend、HelloFriend、Hello三个项目,其中MakeFriend依赖项目HelloFriend,HelloFriend依赖项目Hello。那么在项目HelloFriend种只需要导入HelloFriend,就会自动将Hello也加入到MakeFriend的依赖中。 注意:这种依赖的传递只存在于scope为complie类型的依赖。 八、依赖的排除情景：项目B依赖项目A，项目C依赖项目B，由于依赖的传递性，C在引入依赖B的同时会引入A，但是C不想引入B依赖的A，这时候就需要使用依赖的排除使得C不引入依赖A。在项目C的pom.xml文件中，引入项目B的时候添加如下内容，就能排除对A的依赖。 123456&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;A的groupId&lt;/groupId&gt; &lt;artifactId&gt;A的artifactId&lt;/artifactId&gt; &lt;/exclusion&gt;&lt;/exclusions&gt; 九、maven依赖传递的原则 情景1：项目B依赖低版本的项目A，项目C依赖高版本的A和B，如果在C中引入B和高版本的A，则低版本的A不会被自动引入到C中。 情景2：项目B依赖低版本的项目A，项目C依赖B和高版本的A，项目D依赖C，如果在D中只明确引入C，这时候传递给D的是高版本的A。因为maven依赖的传递按照的是就近原则。 情景3：项目B依赖低版本的项目A，项目C依赖高版本的A，项目D依赖B和C，这时候maven按照先引入优先的原则，来自动引入A。如果D先引入B，则自动引入低版本的A，如果D先引入C则自动引入高版本的A。 十、pom.xml中的properties标签在properties中可以自定义标签，然后在pom.xml的其他位置可以使用“${自定义标签名}”来引用自定义标签的值。例如:通过在properties中自定义标签来统一管理spring各jar包的版本号 1234567891011121314151617181920212223&lt;properties&gt; &lt;spring-version&gt;4.3.7.RELEASE&lt;/spring-version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--引入spring、springmvc需要的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--事务控制需要的jar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--面向切面编程的jar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 十一、聚合与继承1. 继承 情景：Hello依赖的junit为4.0版本，HelloFriend依赖的junit为4.0版本，MakeFriends依赖的junit为4.9版本。由于test类型的依赖不能传递，所以必然会分散在各个模块中，很容易造成版本不一致。 需求：统一管理各模块中junit依赖的版本。 解决思路：将junit依赖统一提取到一个父工程中，然后将父工程引入子工程中，另外在子工程中声明junit依赖时，不指定版本号，以父工程中的依赖为准，便于统一管理依赖。 步骤： 创建一个maven工程作为父工程，注意：打包的方式为pom； 在子工程中声明对父工程的引用； 将子工程的坐标中与父工程中坐标重复的内容删除; 在父工程中统一junit依赖; 在子工程中引入junit依赖时不声明版本号 完整的配置: 父工程的pom.xml 12345678910111213141516171819202122&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Maven_parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; Hello/pom.xml 1234567891011121314151617181920212223242526&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--如果子工程的groupId、version和父工程的一样，这里就不用声明--&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;!-- 在子工程供声明父工程 --&gt; &lt;parent&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Maven_parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 父工程中pom文件的位置 --&gt; &lt;relativePath&gt;../Maven_parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--这里不用声明junit的版本信息--&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; HelloFriend/pom.xml 123456789101112131415161718192021222324252627282930&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt; &lt;parent&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Maven_parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 父工程中pom文件的位置 --&gt; &lt;relativePath&gt;../Maven_parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; MakeFriend/pom.xml 123456789101112131415161718192021222324252627282930&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;makeFriend&lt;/artifactId&gt; &lt;parent&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;Maven_parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../Maven_parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jizuhao.maven&lt;/groupId&gt; &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 特别注意：使用了继承之后install的时候必须要先install父工程 2. 聚合 作用：在父工程中声明聚合之后，就只需要install父工程就能自动完成对子工程的install 操作：在上述父工程的pom.xml中加入如下内容，完成项目的聚合 1234567 &lt;!--创建聚合--&gt; &lt;modules&gt;&lt;!-- 各个子工程的相对路径 --&gt;&lt;module&gt;../Hello&lt;/module&gt;&lt;module&gt;../HelloFriend&lt;/module&gt;&lt;module&gt;../makeFriend&lt;/module&gt; &lt;/modules&gt; 十二、在idea上使用maven开发web项目 创建项目选择maven-&gt;选择骨架为webApps-&gt;在src/main下面创建java文件夹，然后make dir as resources root-&gt;再src下创建test文件夹，然后make dir as test resources root 加入插件方便调试在项目中加入这个插件之后，只需要点击maven-&gt;plugins-&gt;tomcat7-&gt;run就能启动项目，方便对项目进行调试 1234567891011121314&lt;build&gt; &lt;finalName&gt;ssm&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习路线]]></title>
    <url>%2F2019%2F08%2F02%2Fjava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[一、基础知识 编程语言: Java python c 基本语法 基本网络知识: tcp/ip http/https 基本的设计模式 二、工具方面 操作系统：Linux （centos/Ubuntu） 代码管理：svn/git 持续集成：CI/CD Jenkins Java项目管理工具：maven/gradle 三、框架方面应用框架 ssh（spring+structs+hibernate）已过时 ssm spring boot 中间件 MQ消息对列 RPC通讯框架 gRPC thrift dubbo springcloud elasticsearch 搜索引擎 数据库 SQL：MySQL/postgre sql Nosql：redis memcached mongodb elasticsearch 四、架构方面分布式/微服务架构 spring cloud dubbo rpc通信 虚拟化/容器化 Docker 容器化 k8s kubernetes 五、关注源码/性能 JDK 源码以及部分设计思想 Spring源码 JVM细节与排错 高并发/高可用 六、推荐的图书 java编程思想 java并发编程实战 深入理解java虚拟机 head First 设计模式 函数式编程思维 Tcp/Ip详解 卷1/卷2 鸟哥的linux私房菜 spring技术内幕]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的基本语法]]></title>
    <url>%2F2019%2F08%2F01%2Fmarkdowm%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、标题分级123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 注意：标题内容和最后一个#号之间有1个空格。 效果： 二、字体设置1234*这是斜体***这是粗体*****斜体加粗***~删除线~ 效果：这是斜体这是粗体斜体加粗删除线 三、引用123&gt;引用&gt;&gt;引用&gt;&gt;&gt;引用 提示：通过上面的例子可以发现，&#39;&gt;&#39;可以嵌套使用。 效果： 引用 引用 引用 四、分割线1234---***---**** 提示：三个及以上个数的&#39;*&#39;或者&#39;-&#39;都能产生一条横线， 五、引入图片1![图片不见了](/images/logo.jpg &quot;标题&quot;) 提示：[]包裹的图片链接失效时的提示信息，()内前半部分是图片的地址,这里使用的是绝对路径，也可以使用url来引用网络上的图片,鼠标悬浮在图片上时显示的内容，有些浏览器不支持,该内容是可选的。 效果： 六、超链接1[baidu](http://baidu.com) 效果：baidu 七、换行 说明：如果我们想把一行文本进行换行，我们可以在需要换行的地方输入至少两个空格，然后回车即可。 例如： 12markdown 另起一行 效果：markdown另起一行 八、代码块 说明：单行代码使用``这个符号括起来，就能显示成一个代码块。多行代码使用至少4个空格缩进或者一个tab键或者使用``` ```将代码块包起来，都能以代码块的形式显示多行代码。 例如： 12345`&lt;html&gt;&lt;/html&gt;`**** public static void main(String[] args)&#123; System.out.println(&quot;hello world!&quot;); &#125; 效果：&lt;html&gt;&lt;/html&gt; public static void main(String[] args){ System.out.println(&quot;hello world!&quot;); }九、列表 说明：*和+和-后面跟一个空格产生一个无序列表数字或字母后面跟一个.然后再跟一个空格就会产生有序列表 例如： * 列表1 * 子列表1 * 子列表2 - 列表2 - 子列表1 - 子列表2 + 列表3 + 子列表1 + 子列表2 **** 1. 列表1 a. 子列表1 b. 子列表2 2. 列表2 a. 子列表1 b. 子列表2 3. 列表3 a. 子列表1 b. 子列表2效果： 列表1 子列表1 子列表2 列表2 子列表1 子列表2 列表3 子列表1 子列表2 列表1 a. 子列表1 b. 子列表2 列表2 a. 子列表1 b. 子列表2 列表3 a. 子列表1 b. 子列表2 ​]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>标记语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、搭建个人博客的详细过程1.下载安装Node.js Node.js带有一个包管理器npm。安装好Node.js之后，npm会被自动配置到环境变量中。 2.更换npm的源 首先进入cmd，输入如下命令： npm install -g cnpm –registry=https://registry.npm.taobao.org通过这个命令完成了cnpm的安装,并将其源设置为了淘宝的源。接下来将使用cnpm来代替npm。 3.安装Hexo 输入如下指令： cnpm install -g hexo-cli 4.创建博客站点的文件夹 任意再一个路径下创建一个文件夹，之后将在这个文件夹中创建博客站点 5.初始化博客站点 在cmd中进入刚才创建的文件夹中，然后输入如下指令： hexo init提示：如果显示找不到指令hexo，就输入： cnpm install 6.启动本地服务进行测试 初始化博客站点完成之后，输入如下指令开启本地服务： hexo server然后进入浏览器访问localhost:4000，如果成功了会显示一个默认的博客首页，此时已经完成了个人博客的搭建。 二、编写博客的步骤1.编辑博文 在cmd中进入博客站点根目录，然后输入如下指令： hexo new [博文的名字]该指令会在站点目录下的source/_post下生成一个对应的md文件。使用markdown的语法，在这个文件中编写自己的博文内容。 2.生成博客 编辑保存好博文之后，在cmd中进入站点根目录，然后输入如下指令： hexo generate该指令会将站点下的所有博文统一生成一个待发布的静态网站，也就是我们的博客。该网站对应的资源文件在站点根目录下的.deploy_git下。提示：在每次生成博客之前，最好使用clean指令清理之前网站文件夹。 三、将个人博客托管到github1.创建托管博客的仓库 创建一个github仓库，仓库名必须是 username.github.io例如：我的用户名为The-Wanted2,所以我托管博客的仓库名为The-Wanted2.github.io 2.安装发布博客所需的工具 安装发布到github所需的工具,输入:​ cnpm install –save hexo-deployer-git 3.设置仓库的地址 打开站点根目录下的_config.yml文件，修改文件的最后几行，设置github仓库的地址内容如下： 4.发布博文 在cmd中进入站点根目录，输入如下命令： hexo deploy该命令会将站点根目录下的.deploy_git发布到上面指定的仓库中，之后就能通过访问：The-Wanted2.github.io 来访问我的博客。]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
